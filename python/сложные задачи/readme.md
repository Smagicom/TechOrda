#Сложные задачи
#переменная
##sum-1-n 
Дается число n. Вернуть сумму от 1 до n без использования циклов.
Ограничения
1 <= n <= 65535
Sample Input:
5
Sample Output:
15

#ответ
def sum_1_n(n):
    return n * (n + 1) // 2

# Пример использования
n = 5
print(sum_1_n(n))  # Выведет 15




#Циклы

##count-leap-year 
В этой задаче вам нужно вернуть кол-во високосных лет до заданного n года.
Правило для определения високосного года [источник]:
год, номер которого кратен 400, — високосный;
остальные годы, номер которых кратен 100, — невисокосные (например, годы 1700, 1800, 1900, 2100, 2200, 2300);
остальные годы, номер которых кратен 4, — високосные.
все остальные годы — невисокосные.
Допускается, что високосные годы можно считать с 0 года.
Пример
До года 100 присутстует 24 високосных лет.
Ограничения
n > 0
Запрещенные библиотеки, конструкции
for
Sample Input:
4
Sample Output:
1

#ответ

def count_leap_year(n):
    count_div4 = (n - 1) // 4
    count_div100 = (n - 1) // 100
    count_div400 = (n - 1) // 400
    return count_div4 - count_div100 + count_div400

# Пример использования
n = 100
print(count_leap_year(n))  # Выведет 24


##swap-bits 
Реализуйте метод, который меняет местами первые 4 бита с остальными 4 и возвращает результат.
Примеры
0000 1111 -> 1111 0000
0110 0111 -> 0111 0110
Ограничения
0 <= a <= 255
Sample Input:
15
Sample Output:
240

#ответ
def swap_bits(a):
    # Извлечение старших 4 битов
    upper_bits = (a >> 4) & 0b1111
    # Извлечение младших 4 битов
    lower_bits = a & 0b1111
    # Поменять местами и объединить
    result = (lower_bits << 4) | upper_bits
    return result

# Пример использования
a = 15
print(swap_bits(a))  # Выведет 240








#Условия
##sort-nums-three 
Напишите функцию, которая отсортировывает по возрастанию три числа a, b, c, без использования циклов.
Отсортированные числа вывести в консоль.
Пример
3 2 1 -> 1 2 3
Sample Input:
3 2 1
Sample Output:
1 2 3






#Массивы
##median 
Реализовать функцию median, которое находится в середине массива, если его упорядочить по возрастанию, то есть такое число, что половина из элементов набора не меньше него, а другая половина не больше.
Если кол-во элементов в массиве четное, то нужно вернуть левое значение медианы.
Ограничения
0 <= array.length <= 10_000
Sample Input:
[1, 2, 3]
Sample Output:
2

#ответ
def sort_nums_three(a, b, c):
    # Сначала проверим, если a больше b, поменяем их местами
    if a > b:
        a, b = b, a
    # Теперь если b больше c, поменяем их местами
    if b > c:
        b, c = c, b
    # Повторно проверим a и b, потому что a могло быть больше c
    if a > b:
        a, b = b, a
    print(a, b, c)

# Пример использования
a, b, c = 3, 2, 1
sort_nums_three(a, b, c)  # Выведет 1 2 3





##miss-you 
Дается два массива чисел, вернуть числа из второго массива, которые не присутствуют в первом в отсортированном порядке.
Ограничения
0 <= array1.length <= 10_000
0 <= array2.length <= 10_000
Sample Input:
[1, 1, 3, 2, 5]
[1, 3, 9, 1, 5, 7]
Sample Output:
[7, 9]

#ответ
def miss_you(array1, array2):
    # Преобразуем первый массив в множество для быстрого поиска
    set1 = set(array1)
    
    # Находим элементы второго массива, которые не входят в первый массив
    result = sorted(set(x for x in array2 if x not in set1))
    
    return result

# Пример использования
array1 = [1, 1, 3, 2, 5]
array2 = [1, 3, 9, 1, 5, 7]
print(miss_you(array1, array2))  # Выведет [7, 9]



##perfectly-balanced 
Дается массив чисел, найти в массиве такой элемент, где сумма чисел слева равна сумме чисел справа.
Если такое число есть, то вернуть true, в противном случае false.
Пример
Возьмем массив 1, 2, 9, 8, 5, 7
Число 8 является элементом, где сумма чисел слева равна сумме чисел справа.
1   2   9   8   5   7

(1+2+9)=12  ↑  (5+7)=12
Ограничения
0 <= array.length <= 10_000
Sample Input:
[1, 2, 9, 8, 5, 7]
Sample Output:
true

#ответ

def perfectly_balanced(array):
    # Считаем полную сумму всех элементов
    total_sum = sum(array)
    
    # Инициализируем сумму элементов слева
    left_sum = 0
    
    # Проходим по каждому элементу массива
    for i in range(len(array)):
        # Вычитаем текущий элемент из правой суммы
        right_sum = total_sum - left_sum - array[i]
        
        # Проверяем, равны ли суммы слева и справа
        if left_sum == right_sum:
            return True
        
        # Добавляем текущий элемент к левой сумме
        left_sum += array[i]
    
    # Если мы прошли по всему массиву и не нашли, возвращаем False
    return False

# Пример использования
array = [1, 2, 9, 8, 5, 7]
print(perfectly_balanced(array))  # Выведет True



##stock-buy 
Два друга хотят скинуться, чтобы купить акции на Jusan Invest. Им нужно купить две акции на всю сумму, которая у них есть.
Дается доступная сумма денег m и список цен на различные акции s. Напечатайте индексы акции, которые можно купить.
Напечатанные индексы должны быть отсортированы по возрастанию.
Предполагается, что такие числа всегда существуют в списке цен акции s, сумма которых равна m.
Пример
m = 8, s = [8 7 3 1 3 10]
Правильный ответ
1 3
Число по индексу [1] это 7, а по индексу [3] это 1. Соответственно, 7 + 1 = 8.
Ограничения
m > 1
2 <= array.length <= 10_000
Sample Input:
3
[1, 2, 3]
Sample Output:
0 1

#ответ
def stock_buy(m, s):
    # Создаем словарь для хранения индексов
    seen = {}
    
    # Проходим по массиву
    for i, price in enumerate(s):
        # Вычисляем необходимую пару для текущего элемента
        complement = m - price
        
        # Если пара найдена в словаре, возвращаем индексы
        if complement in seen:
            return sorted([seen[complement], i])
        
        # Иначе сохраняем текущую цену и ее индекс в словарь
        seen[price] = i

# Пример использования
m = 8
s = [8, 7, 3, 1, 3, 10]
print(stock_buy(m, s))  # Выведет [1, 3]






	

#Самая сложная задача фукнции
##hanoi-tower 
"Ханойские башни" - это математическая головоломка. Паззл состоит из трех башен и нескольких дисков (бубликов).
Задача состоит в том, что нужно переместить диски из первой башни в последнюю. При этом, диски меньшего размера можно положить сверху большего, но не наоборот.

Напишите функцию hanoiTower, которая принимает число дисков n. Диски расположены на первой башне в порядке возрастания (снизу диски с большим значением, сверху наименьшим). Функция должна напечатать последовательность перекладываний в формате:
Диск a с башни b переложить в башню c
где,
а номер диска
b номер башни, с которой снимают диск
c номер башни, на которую ложат диск
Функция должна вывести минимальное количество команд для перемещения дисков с первой башни на последнюю.
Пример
Пример вывода программы для n = 2
Диск 1 с башни 1 переложить в башню 2
Диск 2 с башни 1 переложить в башню 3
Диск 1 с башни 2 переложить в башню 3
Ограничения
0 < n < 100
Sample Input:
5
Sample Output:
Диск 1 с башни 1 переложить в башню 3
Диск 2 с башни 1 переложить в башню 2
Диск 1 с башни 3 переложить в башню 2
Диск 3 с башни 1 переложить в башню 3
Диск 1 с башни 2 переложить в башню 1
Диск 2 с башни 2 переложить в башню 3
Диск 1 с башни 1 переложить в башню 3
Диск 4 с башни 1 переложить в башню 2
Диск 1 с башни 3 переложить в башню 2
Диск 2 с башни 3 переложить в башню 1
Диск 1 с башни 2 переложить в башню 1
Диск 3 с башни 3 переложить в башню 2
Диск 1 с башни 1 переложить в башню 3
Диск 2 с башни 1 переложить в башню 2
Диск 1 с башни 3 переложить в башню 2
Диск 5 с башни 1 переложить в башню 3
Диск 1 с башни 2 переложить в башню 1
Диск 2 с башни 2 переложить в башню 3
Диск 1 с башни 1 переложить в башню 3
Диск 3 с башни 2 переложить в башню 1
Диск 1 с башни 3 переложить в башню 2
Диск 2 с башни 3 переложить в башню 1
Диск 1 с башни 2 переложить в башню 1
Диск 4 с башни 2 переложить в башню 3
Диск 1 с башни 1 переложить в башню 3
Диск 2 с башни 1 переложить в башню 2
Диск 1 с башни 3 переложить в башню 2
Диск 3 с башни 1 переложить в башню 3
Диск 1 с башни 2 переложить в башню 1
Диск 2 с башни 2 переложить в башню 3
Диск 1 с башни 1 переложить в башню 3

#ответ
def hanoiTower(n, from_tower=1, to_tower=3, aux_tower=2):
    # Базовый случай: если один диск, перемещаем его напрямую
    if n == 1:
        print(f"Диск {n} с башни {from_tower} переложить в башню {to_tower}")
        return
    
    # Шаг 1: Переместить n-1 дисков с from_tower на вспомогательную башню
    hanoiTower(n - 1, from_tower, aux_tower, to_tower)
    
    # Шаг 2: Переместить самый большой диск с from_tower на to_tower
    print(f"Диск {n} с башни {from_tower} переложить в башню {to_tower}")
    
    # Шаг 3: Переместить n-1 дисков с вспомогательной башни на to_tower
    hanoiTower(n - 1, aux_tower, to_tower, from_tower)

# Пример использования
n = 5
hanoiTower(n)

